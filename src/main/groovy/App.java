import java.util.*;
import java.util.function.*;
import java.util.stream.*;

/*
 * This Groovy source file was generated by the Gradle 'init' task.
 */
class App {
    String getGreeting() {
        return "Hello world.";
    }

    public static long sum(List<Integer> values, long maxValue) {
        if (values.isEmpty()) {
            return 0;
        }
        else {
            return sum(values, maxValue, values.size() - 1);


        }

    }
    public static long shares(int[] values) {

        int profit = 0;

        if (values.length <= 1) {
            return profit;
        }

        if (values[1] > values[0]) {
            profit = values[1] - values[0];
            return profit;
        }

        return 0;
    }

    /*
     int totalProfit = 0;
        for (int i = 0; i < values.length; i++) {
            int maxPrice = 0;

            for (int j = i; j < values.length; j++) {
                if (values[j] > maxPrice) {
                    maxPrice = values[j];
                }
            }

            totalProfit = totalProfit + (maxPrice - values[i]);
        }

        return totalProfit;
     */
    public static int bricks(List<Integer> values) {
        if (values.isEmpty()) {
            return 0;
        }
        else if (values.size() <= 4) {
            int toIndex = (values.size() >= 3) ? 3 : values.size();
            return values.subList(0, toIndex).stream().reduce(0, Integer::sum);
        }
        else {
            int sum1 = values.get(0) + bricks(values.subList(4, values.size()));
            int sum2 = values.get(0) + values.get(1) + ((values.size() > 5) ? bricks(values.subList(5, values.size())) : 0);
            int sum3 =  values.get(0) + values.get(1) + values.get(2) + ((values.size() > 6) ? bricks(values.subList(6, values.size())) : 0);

            List<Integer> sums = Arrays.asList(sum1, sum2, sum3);
            return sums.stream().max(Integer::compareTo).get();
        }
    }

    public static long sum(List<Integer> values, long maxValue, int currIdx) {
        if (currIdx < 0) {
            return 0;
        }

        int value = values.get(currIdx);

        if (value == 0) {
            return 0;
        }
        else if (value > maxValue) {
            return (currIdx == 0) ? 0 : sum(values, maxValue, currIdx -1);
        }

        long currMaxValue = getMaxValue(value, maxValue);

        if (currMaxValue == maxValue) {
            return maxValue;
        }
        else {
            List<Long> maxValues = new ArrayList<>();
            //maxValues.add(sum(values, maxValue - value, currIdx -1) + value);
            maxValues.add(sum(values, maxValue, currIdx -1));

            for (int i = 1; i <= maxValue / value; i++ ) {
                int combination = i * value;
                maxValues.add(sum(values, maxValue - combination, currIdx - 1) + combination);
            }

            return maxValues.stream()
                         .max(Long::compareTo)
                        .get();

        }

    }

//            int value1 = values.get(0);
//            int value2 = values.get(1);
//
//            int maxValue1 = getMaxValue(value1, maxValue);
//            int maxValue2 = getMaxValue(value2, maxValue);
//
//            if (maxValue1 == maxValue || maxValue2 == maxValue) {
//                return maxValue;
//            }
//            else if (maxValue1 == 0) {
//                return maxValue2;
//            }
//            else if (maxValue2 == 0) {
//                return maxValue1;
//            }
//
//
//            int updatedMaxValue3 = getMaxValue(value1, (maxValue - value2));
//            int updatedMaxValue4 = getMaxValue(value2, (maxValue - updatedMaxValue3));
//
//            return  updatedMaxValue3 + updatedMaxValue4;

    private static long getMaxValue(long value, long maxValue) {
        if (value == maxValue) {
            return value;
        }
        else if (value > maxValue || value == 0) {
            return 0;
        }
        else if (value == 1) {
            return maxValue;
        }
        else {
            long remainder = value % maxValue;

            if (remainder == 0) {
                return maxValue;
            }
            else {
                return ((long) value) * ((long) maxValue / value);
            }
        }
    }

    public static int steps(int n) {
        return steps(n, new int[n + 1]);
    }

    public static long profit (int[] arr) {
//         for (int i = 0; i < arr.length; i++) {
//             int
//         }

        return 0;
    }

    public static long calories (int[] arr) {
        List<Integer> l = Arrays.stream(arr).boxed().collect(Collectors.toList());

        Collections.sort(l, Collections.reverseOrder());

        int caloriesToBurn = 0;
        int cupcakesEaten = 0;
        for (int i = 0; i < l.size(); i++) {
            caloriesToBurn = caloriesToBurn + ((int)(Math.pow(2, cupcakesEaten)) * l.get(i));
            cupcakesEaten++;
        }

        return caloriesToBurn;
    }

    public static class ProfitAccumulator implements IntConsumer {
        long profitOnBuy = 0;
        long sharesOnBuy = 0;
        long profitOnSell = 0;
        long sharesOnSell = 0;
        long profitOnDoNothing = 0;
        long sharesOnDoNothing = 0;
        long moneySpentOnBuy = 0;


        public void accept(int i) {
           sharesOnBuy++;
           moneySpentOnBuy+= i * i;
           profitOnBuy = (i * sharesOnBuy) - moneySpentOnBuy;

           profitOnSell +=  (i * sharesOnSell) - moneySpentOnBuy;
        }

        public void combine(ProfitAccumulator other) {
            profitOnBuy += other.profitOnBuy;
            profitOnSell += other.profitOnSell;
            profitOnDoNothing += other.profitOnDoNothing;
            sharesOnBuy  += other.sharesOnBuy;
            sharesOnSell += other.sharesOnSell;
            sharesOnDoNothing += other.sharesOnDoNothing;
        }
    }

    public static long minimum(int[] arr) {
        long[] amounts = new long[arr.length];

        for (int i = 0; i < amounts.length; i++) {
            amounts[i] = 1;
        }

        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i] == arr[i +1]) {
                amounts[i+1] = 1;
            }
            else if (arr[i] > arr[i + 1]) {
                if (amounts[i] == amounts[i + 1]) {
                    amounts[i] = amounts[i] + 1;
                    amounts[i+1] = 1;
                }
            }
            else {
                amounts[i + 1] = amounts[i] + 1;
            }
        }

        for (int i = arr.length - 1; i > 0; i--) {
            if (arr[i - 1] > arr[i] && amounts[i - 1] <= amounts[i]) {
                amounts[i -1] = amounts[i] + 1;
            }
        }

        return Arrays.stream(amounts).sum();
    }

    public static int steps(int n, int[] ways) {
        if (ways[n] > 0) {
            return ways[n];
        }

        if (n == 0) {
            ways[0] = 0;
        }
        else if (n == 1) {
            ways[1] = 1;
        }
        else if (n == 2) {
            ways[2] = 2;
        }
        else {
            ways[n] = steps(n -1, ways) + steps(n - 2, ways) + steps( n -3, ways) + 1;
        }
        return ways[n];
    }


    public static String match(String a, String b) {
        if (b.length() > a.length()) {
            return "NO";
        }
        else if (a.toUpperCase().equals(b.toUpperCase())) {
            return "YES";
        }

        int index = 0;
        int bindex = 0;
        int foundIdx = 0;
        char[] achars = a.toCharArray();
        char[] bchars = b.toUpperCase().toCharArray();

        char[] copy = new char[b.length()];

        boolean match = false;
        while (index < achars.length) {
            if (match && Character.isUpperCase(achars[index])) {
                return "NO";
            }
            else if (match && Character.isLowerCase(achars[index])) {
                index++;
                continue;
            }

            if (Character.toUpperCase(achars[index]) == bchars[bindex]) {
                if (Character.isLowerCase(achars[index])) {
                    int acharsDuplicateCharacters = findDuplicateCharsUppercase(achars, index, bchars[bindex]);
                    int bcharsDuplicateCharacters = findDuplicateCharsUppercase(bchars, bindex, bchars[bindex]);

                    if (acharsDuplicateCharacters > bcharsDuplicateCharacters) {
                        index++;
                        continue;
                    }
                }
                copy[foundIdx++] = Character.toUpperCase(achars[index]);
                bindex++;
                if (Arrays.equals(copy, bchars)) {
                    match = true;
                }
            }
            else if (Character.isUpperCase(achars[index])) {
                System.out.println("A string so far is" + (new String(achars)).substring(0,index + 1));
                System.out.println("b string so far is " +  (new String(bchars)).substring(0,bindex + 1));
                System.out.println("string built so far is " + new String(copy));
                System.out.println("A index " + index);
                System.out.println("B index" + bindex);
                return "NO";
            }
            else {
                // deleteting character;
            }
            index++;
        }

        return (match) ? "YES" : "NO";
    }

    public static int findDuplicateChars(char[] value, int startIdx, char match) {

        int idx = startIdx;
        int count = 0;
        while (idx < value.length && Character.toUpperCase(value[idx]) == Character.toUpperCase(match) && Character.isLowerCase(value[idx])) {
            count++;
            idx++;
        }

        return count;
    }

    public static int findDuplicateCharsUppercase(char[] value, int startIdx, char match) {

        int idx = startIdx;
        int count = 0;
        while (idx < value.length && Character.toUpperCase(value[idx]) == Character.toUpperCase(match)) {
            count++;
            idx++;
        }

        return count;
    }
    public static int fib(int n) {
        int[] cache = new int[n + 1];
        System.out.println(cache.length);
        return fib(n, cache);
    }

    public static int fib(int n, int[] cache) {
        if (n == 0) {
            return 0;
        }
        else if (n <= 2) {
            cache[n] = 2;
            return 1;
        }
        else if (cache[n] == 0) {
            cache[n] = fib(n - 1, cache) + fib(n -2, cache);
            return cache[n];
        }
        else {
            return cache[n];
        }
    }

}
